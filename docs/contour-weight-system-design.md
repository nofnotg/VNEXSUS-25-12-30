# ë“±ê³ ì„  ê°€ì¤‘ì¹˜ ì‹œìŠ¤í…œ(Contour Weight System) ìƒì„¸ ì„¤ê³„

## ğŸ“‹ ê°œìš”

**ì‘ì„±ì¼**: 2026-01-31
**ëª©ì **: 3D ì§€ë„ ë“±ê³ ì„  ê°œë…ì„ ì ìš©í•œ OCR ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ ì •ë³´ ì¶”ì¶œ ì‹œìŠ¤í…œ
**í•µì‹¬ ì•„ì´ë””ì–´**: í‚¤ì›Œë“œ ì •í™• ë§¤ì¹­(ë´‰ìš°ë¦¬)ì—ì„œ ì‹œì‘í•˜ì—¬ ì£¼ë³€ ì»¨í…ìŠ¤íŠ¸(ë“±ê³ ì„ )ë¡œ í™•ì¥í•˜ë©° ì •ë³´ ì¶”ì¶œ

---

## ğŸ”ï¸ ê°œë…ì  ê¸°ë°˜

### 3D ì§€í˜• ëª¨ë¸ ë¹„ìœ 

```
              â›°ï¸ ì •ìƒ (Peak) - í‚¤ì›Œë“œ ì •í™• ë§¤ì¹­
             /â”‚\
            / â”‚ \
           /  â”‚  \
          /   â”‚   \      ê³ ë„(ê°€ì¤‘ì¹˜)
    ğŸ”´â”â”â”â”â”â”â”â”â”¿â”â”â”â”â”â”â”â”ğŸ”´  1.0 - ì •ìƒ
         /    â”‚    \
    ğŸŸ â”â”â”â”â”â”â”â”â”¿â”â”â”â”â”â”â”â”ğŸŸ      0.8 - ê³ ì§€
       /      â”‚      \
  ğŸŸ¡â”â”â”â”â”â”â”â”â”â”â”¿â”â”â”â”â”â”â”â”â”â”ğŸŸ¡   0.6 - ì¤‘í„±
     /        â”‚        \
ğŸŸ¢â”â”â”â”â”â”â”â”â”â”â”â”â”¿â”â”â”â”â”â”â”â”â”â”â”â”ğŸŸ¢ 0.4 - ê¸°ìŠ­
   /          â”‚          \
ğŸ”µâ”â”â”â”â”â”â”â”â”â”â”â”â”â”¿â”â”â”â”â”â”â”â”â”â”â”â”â”â”ğŸ”µ 0.2 - í‰ì§€
```

### ë“±ê³ ì„  ë ˆë²¨ ì •ì˜

| ë ˆë²¨ | ê°€ì¤‘ì¹˜ | ìƒ‰ìƒ ì½”ë“œ | ì˜ë¯¸ | ì˜ˆì‹œ |
|------|--------|-----------|------|------|
| **PEAK** | 1.0 | ğŸ”´ #FF0000 | ì •í™• ë§¤ì¹­ | "ë‚´ì›ì¼" í‚¤ì›Œë“œ ì§ì ‘ ë°œê²¬ |
| **HIGH** | 0.8 | ğŸŸ  #FF8800 | ê°•í•œ ì—°ê´€ | "ë°©ë¬¸ì¼", "ì§„ë£Œì¼" ë“± ìœ ì‚¬ í‚¤ì›Œë“œ |
| **MID** | 0.6 | ğŸŸ¡ #FFFF00 | ì¤‘ê°„ ì—°ê´€ | ê°™ì€ ë¬¸ë‹¨ ë‚´ ê´€ë ¨ ì •ë³´ |
| **LOW** | 0.4 | ğŸŸ¢ #88FF88 | ì•½í•œ ì—°ê´€ | ê°™ì€ ì„¹ì…˜ ë‚´ ê´€ë ¨ ì •ë³´ |
| **PLAIN** | 0.2 | ğŸ”µ #0088FF | ë¬´ê´€ | ê´€ë ¨ì„± ì—†ìŒ |

---

## ğŸ¯ ì„¤ê³„ ëª©í‘œ

### 1. ìœ ì—°ì„± (Flexibility)
- ë¬¸ì„œë§ˆë‹¤ ë‹¤ë¥¸ í‘œí˜„ ë°©ì‹ ëŒ€ì‘
- í‚¤ì›Œë“œ ì •í™• ë§¤ì¹­ ì‹¤íŒ¨ ì‹œì—ë„ ì •ë³´ ì¶”ì¶œ ê°€ëŠ¥
- ìƒˆë¡œìš´ ë¬¸ì„œ í˜•ì‹ì— ëŒ€í•œ ì ì‘ë ¥

### 2. ì •í™•ì„± (Accuracy)
- ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì‹ ë¢°ë„ ì •ëŸ‰í™”
- ê´€ë ¨ì„± ë†’ì€ ì •ë³´ ìš°ì„  ì¶”ì¶œ
- ë…¸ì´ì¦ˆ í•„í„°ë§

### 3. í™•ì¥ì„± (Scalability)
- ìƒˆë¡œìš´ ì¹´í…Œê³ ë¦¬ ì¶”ê°€ ìš©ì´
- í‚¤ì›Œë“œ ê³„ì¸µ êµ¬ì¡° í™•ì¥ ê°€ëŠ¥
- ë‹¤ì–‘í•œ ë„ë©”ì¸ ì ìš© ê°€ëŠ¥

### 4. í•´ì„ ê°€ëŠ¥ì„± (Interpretability)
- ì¶”ì¶œ ê·¼ê±° ëª…í™•íˆ ì œì‹œ
- ê°€ì¤‘ì¹˜ë¡œ ì‹ ë¢°ë„ í‘œí˜„
- ë“±ê³ ì„  ì‹œê°í™” ê°€ëŠ¥

---

## ğŸ—ï¸ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜

### ì „ì²´ êµ¬ì¡°

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    OCR Blocks Input                         â”‚
â”‚  [block1, block2, block3, ...]                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              1. Peak Detection (ë´‰ìš°ë¦¬ íƒì§€)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ KeywordMatcher                                        â”‚  â”‚
â”‚  â”‚ - ì •í™• ë§¤ì¹­: "ë‚´ì›ì¼" â†’ PEAK                          â”‚  â”‚
â”‚  â”‚ - ìœ ì‚¬ ë§¤ì¹­: "ë°©ë¬¸ì¼" â†’ HIGH                          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         2. Contour Expansion (ë“±ê³ ì„  í™•ì¥)                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ProximityAnalyzer                                     â”‚  â”‚
â”‚  â”‚ - BBox ê±°ë¦¬ ê³„ì‚°                                      â”‚  â”‚
â”‚  â”‚ - ê·¼ì ‘ ë¸”ë¡ ìˆ˜ì§‘                                      â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          3. Weight Calculation (ê°€ì¤‘ì¹˜ ê³„ì‚°)                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ WeightCalculator                                      â”‚  â”‚
â”‚  â”‚ - í‚¤ì›Œë“œ ë ˆë²¨ ê°€ì¤‘ì¹˜                                  â”‚  â”‚
â”‚  â”‚ - ê±°ë¦¬ ê¸°ë°˜ ê°€ì¤‘ì¹˜                                    â”‚  â”‚
â”‚  â”‚ - ì»¨í…ìŠ¤íŠ¸ ê°€ì¤‘ì¹˜                                     â”‚  â”‚
â”‚  â”‚ - OCR ì‹ ë¢°ë„ ê°€ì¤‘ì¹˜                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           4. Flow Analysis (íë¦„ ë¶„ì„)                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚ ContextFlowAnalyzer                                   â”‚  â”‚
â”‚  â”‚ - ì •ìƒ â†’ ê¸°ìŠ­ ì¼ê´€ì„± ê²€ì¦                            â”‚  â”‚
â”‚  â”‚ - ì •ë³´ ì¶”ì¶œ ë° í†µí•©                                   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              5. Result Generation (ê²°ê³¼ ìƒì„±)               â”‚
â”‚  {                                                          â”‚
â”‚    category: "ë‚´ì›ì¼",                                      â”‚
â”‚    value: "2023-01-15",                                     â”‚
â”‚    confidence: 0.92,                                        â”‚
â”‚    contours: { peak: [...], high: [...], mid: [...] },     â”‚
â”‚    source: { blocks: [...], weights: [...] }               â”‚
â”‚  }                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ì„¤ê³„

### 1. ContourWeightClassifier

**ì±…ì„**: ë“±ê³ ì„  ë ˆë²¨ ë¶„ë¥˜ ë° ê°€ì¤‘ì¹˜ ê³„ì‚°

```javascript
class ContourWeightClassifier {
  constructor(config = {}) {
    // ë“±ê³ ì„  ë ˆë²¨ ì •ì˜
    this.contourLevels = {
      PEAK: { weight: 1.0, threshold: 0.9, color: '#FF0000', name: 'ì •ìƒ' },
      HIGH: { weight: 0.8, threshold: 0.7, color: '#FF8800', name: 'ê³ ì§€' },
      MID: { weight: 0.6, threshold: 0.5, color: '#FFFF00', name: 'ì¤‘í„±' },
      LOW: { weight: 0.4, threshold: 0.3, color: '#88FF88', name: 'ê¸°ìŠ­' },
      PLAIN: { weight: 0.2, threshold: 0.0, color: '#0088FF', name: 'í‰ì§€' }
    };

    // ê±°ë¦¬ ì„ê³„ê°’ (í”½ì…€ ë‹¨ìœ„, ì •ê·œí™”ëœ ì¢Œí‘œ ê¸°ì¤€)
    this.distanceThresholds = {
      PEAK: 0.02,   // 2% ì´ë‚´
      HIGH: 0.05,   // 5% ì´ë‚´
      MID: 0.10,    // 10% ì´ë‚´
      LOW: 0.20,    // 20% ì´ë‚´
    };

    // í‚¤ì›Œë“œ ê³„ì¸µ êµ¬ì¡°
    this.keywordHierarchy = config.keywordHierarchy || this.getDefaultHierarchy();

    // OCR ì‹ ë¢°ë„ ê°€ì¤‘ì¹˜
    this.ocrConfidenceWeight = config.ocrConfidenceWeight || 0.3;
  }

  getDefaultHierarchy() {
    return {
      'ë‚´ì›ì¼': {
        peak: ['ë‚´ì›ì¼', 'ë‚´ì›ì¼ì‹œ', 'ë‚´ì› ì¼ì‹œ'],
        high: ['ë°©ë¬¸ì¼', 'ì§„ë£Œì¼', 'ì§„ì°°ì¼', 'ìˆ˜ì§„ì¼'],
        mid: ['ê²€ì‚¬ì¼', 'ì ‘ìˆ˜ì¼', 'ë“±ë¡ì¼'],
        low: ['ì˜ˆì•½ì¼', 'ì‹ ì²­ì¼']
      },
      'ì§„ë‹¨ëª…': {
        peak: ['ì§„ë‹¨ëª…', 'ì§„ë‹¨', 'ìµœì¢…ì§„ë‹¨'],
        high: ['ì§ˆë³‘ëª…', 'ë³‘ëª…', 'ìƒë³‘ëª…', 'ìƒë³‘'],
        mid: ['ì†Œê²¬', 'íŒì •', 'ì˜ê²¬'],
        low: ['ì¦ìƒ', 'ì£¼ì†Œ', 'CC']
      },
      'ì²˜ë°©': {
        peak: ['ì²˜ë°©', 'ì²˜ë°©ì „', 'ì²˜ë°©ë‚´ì—­'],
        high: ['íˆ¬ì•½', 'ì•½ë¬¼', 'ì˜ì•½í’ˆ'],
        mid: ['ë³µìš©', 'ìš©ë²•', 'ìš©ëŸ‰'],
        low: ['ì œí’ˆëª…', 'ì„±ë¶„']
      },
      'ê²€ì‚¬': {
        peak: ['ê²€ì‚¬', 'ê²€ì‚¬ëª…', 'ê²€ì‚¬í•­ëª©'],
        high: ['Lab', 'ì„ìƒê²€ì‚¬', 'ì§„ë‹¨ê²€ì‚¬'],
        mid: ['ì¸¡ì •', 'ë¶„ì„', 'íŒë…'],
        low: ['ìˆ˜ì¹˜', 'ê²°ê³¼ê°’']
      },
      'ìˆ˜ìˆ ì‹œìˆ ': {
        peak: ['ìˆ˜ìˆ ', 'ì‹œìˆ ', 'ìˆ˜ìˆ ëª…', 'ì‹œìˆ ëª…'],
        high: ['ì˜¤í¼ë ˆì´ì…˜', 'Operation', 'Procedure'],
        mid: ['ì²˜ì¹˜', 'ì¹˜ë£Œ', 'ìš”ë²•'],
        low: ['ë§ˆì·¨', 'ë´‰í•©']
      }
    };
  }

  /**
   * ë´‰ìš°ë¦¬(Peak) íƒì§€
   * @param {Array} ocrBlocks - OCR ë¸”ë¡ ë°°ì—´
   * @param {String} category - ì¹´í…Œê³ ë¦¬ (ì˜ˆ: 'ë‚´ì›ì¼')
   * @returns {Array} ë°œê²¬ëœ ë´‰ìš°ë¦¬ ë¸”ë¡ë“¤
   */
  findPeaks(ocrBlocks, category) {
    const hierarchy = this.keywordHierarchy[category];
    if (!hierarchy) {
      throw new Error(`Unknown category: ${category}`);
    }

    const peaks = [];

    ocrBlocks.forEach(block => {
      const level = this.matchKeywordLevel(block.text, hierarchy);

      if (level === 'peak' || level === 'high') {
        peaks.push({
          block: block,
          level: level,
          weight: this.contourLevels[level.toUpperCase()].weight,
          category: category
        });
      }
    });

    return peaks;
  }

  /**
   * í‚¤ì›Œë“œ ë ˆë²¨ ë§¤ì¹­
   * @param {String} text - ë¸”ë¡ í…ìŠ¤íŠ¸
   * @param {Object} hierarchy - í‚¤ì›Œë“œ ê³„ì¸µ
   * @returns {String} ë§¤ì¹­ëœ ë ˆë²¨ (peak/high/mid/low/plain)
   */
  matchKeywordLevel(text, hierarchy) {
    const normalizedText = text.toLowerCase().trim();

    // ìš°ì„ ìˆœìœ„ ìˆœìœ¼ë¡œ ë§¤ì¹­
    for (const level of ['peak', 'high', 'mid', 'low']) {
      const keywords = hierarchy[level] || [];

      for (const keyword of keywords) {
        if (normalizedText.includes(keyword.toLowerCase())) {
          return level;
        }
      }
    }

    return 'plain';
  }

  /**
   * ë“±ê³ ì„  í™•ì¥ (ë´‰ìš°ë¦¬ë¡œë¶€í„° ì£¼ë³€ ë¸”ë¡ ìˆ˜ì§‘)
   * @param {Object} peakBlock - ë´‰ìš°ë¦¬ ë¸”ë¡
   * @param {Array} allBlocks - ëª¨ë“  OCR ë¸”ë¡
   * @param {Object} hierarchy - í‚¤ì›Œë“œ ê³„ì¸µ
   * @returns {Object} ë“±ê³ ì„  ë ˆë²¨ë³„ ë¸”ë¡ ê·¸ë£¹
   */
  expandContours(peakBlock, allBlocks, hierarchy) {
    const contours = {
      peak: [peakBlock],
      high: [],
      mid: [],
      low: [],
      plain: []
    };

    // ê·¼ì ‘ ë¸”ë¡ ìˆ˜ì§‘
    const nearbyBlocks = this.findNearbyBlocks(
      peakBlock.block,
      allBlocks,
      maxDistance: 0.3  // ì •ê·œí™”ëœ ê±°ë¦¬ 30%
    );

    // ê° ë¸”ë¡ì„ ë“±ê³ ì„  ë ˆë²¨ë¡œ ë¶„ë¥˜
    nearbyBlocks.forEach(block => {
      const levelInfo = this.classifyContourLevel(
        block,
        peakBlock.block,
        hierarchy
      );

      contours[levelInfo.level].push({
        block: block,
        weight: levelInfo.weight,
        distance: levelInfo.distance,
        ocrConfidence: block.confidence || 1.0
      });
    });

    return contours;
  }

  /**
   * ë“±ê³ ì„  ë ˆë²¨ ë¶„ë¥˜ (ì¢…í•© ê°€ì¤‘ì¹˜ ê³„ì‚°)
   * @param {Object} block - ë¶„ë¥˜í•  ë¸”ë¡
   * @param {Object} peakBlock - ê¸°ì¤€ ë´‰ìš°ë¦¬ ë¸”ë¡
   * @param {Object} hierarchy - í‚¤ì›Œë“œ ê³„ì¸µ
   * @returns {Object} { level, weight, distance }
   */
  classifyContourLevel(block, peakBlock, hierarchy) {
    // 1. í‚¤ì›Œë“œ ê¸°ë°˜ ê°€ì¤‘ì¹˜
    const keywordLevel = this.matchKeywordLevel(block.text, hierarchy);
    const keywordWeight = this.contourLevels[keywordLevel.toUpperCase()].weight;

    // 2. ê±°ë¦¬ ê¸°ë°˜ ê°€ì¤‘ì¹˜
    const distance = this.calculateNormalizedDistance(block.bbox, peakBlock.bbox);
    const distanceWeight = this.getDistanceWeight(distance);

    // 3. ì»¨í…ìŠ¤íŠ¸ ê°€ì¤‘ì¹˜ (ê°™ì€ ë¼ì¸/ë‹¨ë½/ì„¹ì…˜)
    const contextWeight = this.getContextWeight(block, peakBlock);

    // 4. OCR ì‹ ë¢°ë„ ê°€ì¤‘ì¹˜
    const ocrWeight = (block.confidence || 1.0);

    // 5. ì¢…í•© ê°€ì¤‘ì¹˜ ê³„ì‚°
    const totalWeight = (
      keywordWeight * 0.4 +        // í‚¤ì›Œë“œ 40%
      distanceWeight * 0.3 +        // ê±°ë¦¬ 30%
      contextWeight * 0.2 +         // ì»¨í…ìŠ¤íŠ¸ 20%
      ocrWeight * 0.1               // OCR ì‹ ë¢°ë„ 10%
    );

    // 6. ê°€ì¤‘ì¹˜ë¥¼ ë ˆë²¨ë¡œ ë³€í™˜
    const level = this.weightToLevel(totalWeight);

    return {
      level: level,
      weight: totalWeight,
      distance: distance,
      breakdown: {
        keyword: keywordWeight,
        distance: distanceWeight,
        context: contextWeight,
        ocr: ocrWeight
      }
    };
  }

  /**
   * ì •ê·œí™”ëœ BBox ê±°ë¦¬ ê³„ì‚°
   * @param {Object} bbox1 - ì²« ë²ˆì§¸ BBox
   * @param {Object} bbox2 - ë‘ ë²ˆì§¸ BBox
   * @returns {Number} ì •ê·œí™”ëœ ê±°ë¦¬ (0~1)
   */
  calculateNormalizedDistance(bbox1, bbox2) {
    // ì¤‘ì‹¬ì  ê³„ì‚°
    const center1 = {
      x: bbox1.Left + bbox1.Width / 2,
      y: bbox1.Top + bbox1.Height / 2
    };
    const center2 = {
      x: bbox2.Left + bbox2.Width / 2,
      y: bbox2.Top + bbox2.Height / 2
    };

    // ìœ í´ë¦¬ë“œ ê±°ë¦¬ (ì´ë¯¸ 0~1 ì •ê·œí™”ëœ ì¢Œí‘œ)
    const distance = Math.sqrt(
      Math.pow(center1.x - center2.x, 2) +
      Math.pow(center1.y - center2.y, 2)
    );

    return distance;
  }

  /**
   * ê±°ë¦¬ ê¸°ë°˜ ê°€ì¤‘ì¹˜ ê³„ì‚°
   * @param {Number} distance - ì •ê·œí™”ëœ ê±°ë¦¬
   * @returns {Number} ê°€ì¤‘ì¹˜ (0~1)
   */
  getDistanceWeight(distance) {
    // ë“±ê³ ì„  ê°œë…: ê±°ë¦¬ì— ë”°ë¼ ì§€ìˆ˜ì ìœ¼ë¡œ ê°ì†Œ
    const thresholds = this.distanceThresholds;

    if (distance < thresholds.PEAK) return 1.0;
    if (distance < thresholds.HIGH) return 0.8;
    if (distance < thresholds.MID) return 0.6;
    if (distance < thresholds.LOW) return 0.4;

    // ê±°ë¦¬ê°€ ë©€ìˆ˜ë¡ ê°€ì¤‘ì¹˜ ê°ì†Œ (ì§€ìˆ˜ í•¨ìˆ˜)
    return Math.max(0.2, Math.exp(-distance * 3));
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ ê°€ì¤‘ì¹˜ ê³„ì‚°
   * @param {Object} block - ë¸”ë¡
   * @param {Object} peakBlock - ë´‰ìš°ë¦¬ ë¸”ë¡
   * @returns {Number} ê°€ì¤‘ì¹˜ (0~1)
   */
  getContextWeight(block, peakBlock) {
    // ê°™ì€ ë¼ì¸
    if (this.isSameLine(block, peakBlock)) {
      return 1.0;
    }

    // ê°™ì€ ë‹¨ë½ (y ì¢Œí‘œ ê·¼ì ‘)
    if (this.isSameParagraph(block, peakBlock)) {
      return 0.7;
    }

    // ê°™ì€ ì„¹ì…˜ (í˜ì´ì§€ ë‚´)
    if (this.isSamePage(block, peakBlock)) {
      return 0.4;
    }

    return 0.2;
  }

  /**
   * ê°™ì€ ë¼ì¸ ì—¬ë¶€ í™•ì¸
   */
  isSameLine(block1, block2) {
    const yDiff = Math.abs(block1.bbox.Top - block2.bbox.Top);
    const avgHeight = (block1.bbox.Height + block2.bbox.Height) / 2;

    // y ì¢Œí‘œ ì°¨ì´ê°€ í‰ê·  ë†’ì´ì˜ 50% ì´ë‚´
    return yDiff < avgHeight * 0.5;
  }

  /**
   * ê°™ì€ ë‹¨ë½ ì—¬ë¶€ í™•ì¸
   */
  isSameParagraph(block1, block2) {
    const yDiff = Math.abs(block1.bbox.Top - block2.bbox.Top);

    // y ì¢Œí‘œ ì°¨ì´ê°€ 0.05 (5%) ì´ë‚´
    return yDiff < 0.05;
  }

  /**
   * ê°™ì€ í˜ì´ì§€ ì—¬ë¶€ í™•ì¸
   */
  isSamePage(block1, block2) {
    return block1.page === block2.page;
  }

  /**
   * ê°€ì¤‘ì¹˜ë¥¼ ë ˆë²¨ë¡œ ë³€í™˜
   */
  weightToLevel(weight) {
    if (weight >= 0.9) return 'peak';
    if (weight >= 0.7) return 'high';
    if (weight >= 0.5) return 'mid';
    if (weight >= 0.3) return 'low';
    return 'plain';
  }

  /**
   * ê·¼ì ‘ ë¸”ë¡ ì°¾ê¸°
   */
  findNearbyBlocks(centerBlock, allBlocks, maxDistance) {
    return allBlocks.filter(block => {
      if (block === centerBlock) return false;

      const distance = this.calculateNormalizedDistance(
        centerBlock.bbox,
        block.bbox
      );

      return distance <= maxDistance;
    });
  }
}
```

---

### 2. ContextFlowAnalyzer

**ì±…ì„**: ë“±ê³ ì„  íë¦„ ë¶„ì„ ë° ì •ë³´ ì¶”ì¶œ

```javascript
class ContextFlowAnalyzer {
  constructor(classifier) {
    this.classifier = classifier;
  }

  /**
   * ë“±ê³ ì„  íë¦„ ë¶„ì„
   * @param {Object} contours - ë“±ê³ ì„  ë ˆë²¨ë³„ ë¸”ë¡
   * @param {String} category - ì¹´í…Œê³ ë¦¬
   * @returns {Object} ì¶”ì¶œëœ ì •ë³´ ë° ì‹ ë¢°ë„
   */
  analyzeFlow(contours, category) {
    // 1. ê° ë ˆë²¨ì—ì„œ ì •ë³´ ì¶”ì¶œ
    const extracted = {
      anchor: this.extractFromLevel(contours.peak, category),
      supporting: this.extractFromLevel(contours.high, category),
      related: this.extractFromLevel(contours.mid, category),
      peripheral: this.extractFromLevel(contours.low, category)
    };

    // 2. íë¦„ ì¼ê´€ì„± ê²€ì¦
    const consistency = this.validateFlowConsistency(extracted, category);

    // 3. ì‹ ë¢°ë„ ê³„ì‚°
    const confidence = this.calculateFlowConfidence(extracted, consistency);

    // 4. ìµœì¢… ì •ë³´ í†µí•©
    const finalInfo = this.integrateInformation(extracted, consistency);

    return {
      category: category,
      value: finalInfo.value,
      confidence: confidence,
      source: {
        contours: contours,
        extracted: extracted,
        consistency: consistency
      },
      metadata: finalInfo.metadata
    };
  }

  /**
   * ë ˆë²¨ë³„ ì •ë³´ ì¶”ì¶œ
   */
  extractFromLevel(levelBlocks, category) {
    switch(category) {
      case 'ë‚´ì›ì¼':
        return this.extractVisitDate(levelBlocks);
      case 'ì§„ë‹¨ëª…':
        return this.extractDiagnosis(levelBlocks);
      case 'ì²˜ë°©':
        return this.extractPrescription(levelBlocks);
      case 'ê²€ì‚¬':
        return this.extractLabTest(levelBlocks);
      case 'ìˆ˜ìˆ ì‹œìˆ ':
        return this.extractProcedure(levelBlocks);
      default:
        return this.extractGeneric(levelBlocks);
    }
  }

  /**
   * ë‚´ì›ì¼ ì¶”ì¶œ
   */
  extractVisitDate(blocks) {
    const datePattern = /(\d{4})[-.ë…„]\s*(\d{1,2})[-.ì›”]\s*(\d{1,2})ì¼?/g;
    const dates = [];

    blocks.forEach(blockInfo => {
      const text = blockInfo.block.text;
      const matches = [...text.matchAll(datePattern)];

      matches.forEach(match => {
        const dateStr = `${match[1]}-${match[2].padStart(2, '0')}-${match[3].padStart(2, '0')}`;

        dates.push({
          value: dateStr,
          weight: blockInfo.weight,
          rawText: match[0],
          block: blockInfo.block
        });
      });
    });

    return dates;
  }

  /**
   * ì§„ë‹¨ëª… ì¶”ì¶œ
   */
  extractDiagnosis(blocks) {
    const icdPattern = /([A-Z]\d{2}\.?\d?)/g;  // ICD-10 ì½”ë“œ
    const diagnoses = [];

    blocks.forEach(blockInfo => {
      const text = blockInfo.block.text;

      // ICD ì½”ë“œ ì°¾ê¸°
      const icdMatches = [...text.matchAll(icdPattern)];

      icdMatches.forEach(match => {
        const code = match[1];

        // ì½”ë“œ ì£¼ë³€ í…ìŠ¤íŠ¸ì—ì„œ ì§„ë‹¨ëª… ì¶”ì¶œ
        const contextText = this.getContextText(text, match.index, 50);

        diagnoses.push({
          code: code,
          name: contextText,
          weight: blockInfo.weight,
          block: blockInfo.block
        });
      });
    });

    return diagnoses;
  }

  /**
   * íë¦„ ì¼ê´€ì„± ê²€ì¦
   */
  validateFlowConsistency(extracted, category) {
    const checks = {
      anchorPresent: extracted.anchor.length > 0,
      supportingRelevant: false,
      dataContinuity: false,
      noConflict: true
    };

    // 1. Anchor ì¡´ì¬ í™•ì¸
    if (!checks.anchorPresent) {
      return { valid: false, checks: checks, score: 0 };
    }

    // 2. Supporting ë°ì´í„° ê´€ë ¨ì„± í™•ì¸
    if (category === 'ë‚´ì›ì¼') {
      const anchorDate = extracted.anchor[0]?.value;

      if (anchorDate) {
        // Supportingì—ì„œë„ ê°™ì€ ë‚ ì§œ ì–¸ê¸‰ í™•ì¸
        checks.supportingRelevant = extracted.supporting.some(item =>
          item.value === anchorDate || item.rawText?.includes(anchorDate)
        );
      }
    }

    // 3. ë°ì´í„° ì—°ì†ì„± í™•ì¸ (Peak â†’ High â†’ Mid â†’ Low ì¼ê´€ì„±)
    checks.dataContinuity = this.checkDataContinuity(extracted);

    // 4. ì¶©ëŒ í™•ì¸
    checks.noConflict = this.checkNoConflict(extracted);

    // 5. ì¢…í•© ì ìˆ˜
    const score = (
      (checks.anchorPresent ? 0.4 : 0) +
      (checks.supportingRelevant ? 0.3 : 0) +
      (checks.dataContinuity ? 0.2 : 0) +
      (checks.noConflict ? 0.1 : 0)
    );

    return {
      valid: score >= 0.6,
      checks: checks,
      score: score
    };
  }

  /**
   * ë°ì´í„° ì—°ì†ì„± í™•ì¸
   */
  checkDataContinuity(extracted) {
    // ê° ë ˆë²¨ì´ ì´ì „ ë ˆë²¨ê³¼ ì¼ê´€ëœ ì •ë³´ë¥¼ í¬í•¨í•˜ëŠ”ì§€ í™•ì¸
    const levels = ['anchor', 'supporting', 'related', 'peripheral'];

    for (let i = 0; i < levels.length - 1; i++) {
      const currentLevel = extracted[levels[i]];
      const nextLevel = extracted[levels[i + 1]];

      if (currentLevel.length === 0) continue;

      // ë‹¤ìŒ ë ˆë²¨ì´ í˜„ì¬ ë ˆë²¨ì˜ ì •ë³´ë¥¼ ë³´ê°•í•˜ê±°ë‚˜ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
      const hasContinuity = this.checkLevelContinuity(currentLevel, nextLevel);

      if (!hasContinuity) {
        return false;
      }
    }

    return true;
  }

  /**
   * ë ˆë²¨ ê°„ ì—°ì†ì„± í™•ì¸
   */
  checkLevelContinuity(currentLevel, nextLevel) {
    if (nextLevel.length === 0) return true; // ë‹¤ìŒ ë ˆë²¨ì´ ì—†ìœ¼ë©´ OK

    // í˜„ì¬ ë ˆë²¨ì˜ ì£¼ìš” ê°’
    const currentValues = currentLevel.map(item => item.value || item.rawText);

    // ë‹¤ìŒ ë ˆë²¨ì—ì„œ í˜„ì¬ ë ˆë²¨ ê°’ ì–¸ê¸‰ í™•ì¸
    return nextLevel.some(item => {
      const itemText = item.value || item.rawText || '';

      return currentValues.some(val =>
        itemText.includes(val) || val.includes(itemText)
      );
    });
  }

  /**
   * ì¶©ëŒ í™•ì¸ (ìƒë°˜ëœ ì •ë³´ ì¡´ì¬ ì—¬ë¶€)
   */
  checkNoConflict(extracted) {
    // ì˜ˆ: ê°™ì€ ì¹´í…Œê³ ë¦¬ì—ì„œ ë‹¤ë¥¸ ë‚ ì§œê°€ ì¶”ì¶œë˜ë©´ ì¶©ëŒ
    const allValues = [
      ...extracted.anchor,
      ...extracted.supporting,
      ...extracted.related
    ].map(item => item.value);

    // ì¤‘ë³µ ì œê±°
    const uniqueValues = [...new Set(allValues)];

    // ê°’ì´ ë„ˆë¬´ ë§ìœ¼ë©´ ì¶©ëŒ ê°€ëŠ¥ì„±
    return uniqueValues.length <= 3;
  }

  /**
   * íë¦„ ì‹ ë¢°ë„ ê³„ì‚°
   */
  calculateFlowConfidence(extracted, consistency) {
    // 1. ì¼ê´€ì„± ì ìˆ˜
    const consistencyScore = consistency.score;

    // 2. ë¸”ë¡ ê°€ì¤‘ì¹˜ í‰ê· 
    const allBlocks = [
      ...extracted.anchor,
      ...extracted.supporting,
      ...extracted.related
    ];

    const avgWeight = allBlocks.length > 0
      ? allBlocks.reduce((sum, b) => sum + (b.weight || 0), 0) / allBlocks.length
      : 0;

    // 3. ë ˆë²¨ ë¶„í¬ ì ìˆ˜ (ì—¬ëŸ¬ ë ˆë²¨ì—ì„œ ì •ë³´ê°€ ìˆìœ¼ë©´ ë” ì‹ ë¢°)
    const levelCount = [
      extracted.anchor.length > 0 ? 1 : 0,
      extracted.supporting.length > 0 ? 1 : 0,
      extracted.related.length > 0 ? 1 : 0
    ].reduce((a, b) => a + b, 0);

    const levelScore = levelCount / 3;

    // 4. ì¢…í•© ì‹ ë¢°ë„
    const confidence = (
      consistencyScore * 0.5 +
      avgWeight * 0.3 +
      levelScore * 0.2
    );

    return Math.min(1.0, Math.max(0.0, confidence));
  }

  /**
   * ì •ë³´ í†µí•©
   */
  integrateInformation(extracted, consistency) {
    // Anchor ìš°ì„ , ì—†ìœ¼ë©´ Supporting, ê·¸ ë‹¤ìŒ Related
    let value = null;
    let metadata = {};

    if (extracted.anchor.length > 0) {
      value = extracted.anchor[0].value;
      metadata.source = 'anchor';
      metadata.weight = extracted.anchor[0].weight;
    } else if (extracted.supporting.length > 0) {
      value = extracted.supporting[0].value;
      metadata.source = 'supporting';
      metadata.weight = extracted.supporting[0].weight;
    } else if (extracted.related.length > 0) {
      value = extracted.related[0].value;
      metadata.source = 'related';
      metadata.weight = extracted.related[0].weight;
    }

    // ë³´ê°• ì •ë³´ ì¶”ê°€
    metadata.alternatives = [
      ...extracted.anchor.slice(1),
      ...extracted.supporting,
      ...extracted.related
    ].map(item => ({
      value: item.value,
      weight: item.weight
    }));

    return { value, metadata };
  }

  /**
   * ì»¨í…ìŠ¤íŠ¸ í…ìŠ¤íŠ¸ ì¶”ì¶œ
   */
  getContextText(text, position, range) {
    const start = Math.max(0, position - range);
    const end = Math.min(text.length, position + range);

    return text.substring(start, end).trim();
  }
}
```

---

## ğŸ¨ ì‹œê°í™” ì‹œìŠ¤í…œ

### ë“±ê³ ì„  íˆíŠ¸ë§µ ì‹œê°í™”

```javascript
class ContourVisualizer {
  /**
   * ë“±ê³ ì„  íˆíŠ¸ë§µ ìƒì„±
   */
  generateHeatmap(contours, pageWidth = 1000, pageHeight = 1414) {
    const canvas = document.createElement('canvas');
    canvas.width = pageWidth;
    canvas.height = pageHeight;

    const ctx = canvas.getContext('2d');

    // ë°°ê²½
    ctx.fillStyle = '#FFFFFF';
    ctx.fillRect(0, 0, pageWidth, pageHeight);

    // ê° ë ˆë²¨ë³„ ë¸”ë¡ ê·¸ë¦¬ê¸°
    const levels = ['peak', 'high', 'mid', 'low', 'plain'];

    levels.forEach(level => {
      const blocks = contours[level] || [];

      blocks.forEach(blockInfo => {
        const block = blockInfo.block;
        const bbox = block.bbox;

        // BBoxë¥¼ í”½ì…€ ì¢Œí‘œë¡œ ë³€í™˜
        const x = bbox.Left * pageWidth;
        const y = bbox.Top * pageHeight;
        const width = bbox.Width * pageWidth;
        const height = bbox.Height * pageHeight;

        // ë ˆë²¨ ìƒ‰ìƒ
        const color = this.getLevelColor(level, blockInfo.weight);

        // ì‚¬ê°í˜• ê·¸ë¦¬ê¸°
        ctx.fillStyle = color;
        ctx.fillRect(x, y, width, height);

        // í…Œë‘ë¦¬
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, width, height);

        // ê°€ì¤‘ì¹˜ í‘œì‹œ
        ctx.fillStyle = '#000000';
        ctx.font = '12px Arial';
        ctx.fillText(
          `${blockInfo.weight.toFixed(2)}`,
          x + 5,
          y + height / 2
        );
      });
    });

    return canvas;
  }

  /**
   * ë ˆë²¨ ìƒ‰ìƒ (ê°€ì¤‘ì¹˜ì— ë”°ë¼ íˆ¬ëª…ë„ ì¡°ì ˆ)
   */
  getLevelColor(level, weight) {
    const colors = {
      peak: '#FF0000',
      high: '#FF8800',
      mid: '#FFFF00',
      low: '#88FF88',
      plain: '#0088FF'
    };

    const baseColor = colors[level] || '#CCCCCC';
    const alpha = 0.3 + (weight * 0.7); // 0.3 ~ 1.0

    return this.hexToRgba(baseColor, alpha);
  }

  hexToRgba(hex, alpha) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);

    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }

  /**
   * ë“±ê³ ì„  íë¦„ ë‹¤ì´ì–´ê·¸ë¨
   */
  generateFlowDiagram(extracted) {
    // D3.jsë‚˜ SVGë¡œ íë¦„ ì‹œê°í™”
    // Peak â†’ High â†’ Mid â†’ Low ì—°ê²°ì„  í‘œì‹œ

    return `
      <svg width="800" height="600">
        <!-- Peak -->
        <circle cx="400" cy="100" r="50" fill="#FF0000" opacity="0.7"/>
        <text x="400" y="105" text-anchor="middle" fill="white">
          Peak
        </text>

        <!-- High -->
        <circle cx="400" cy="200" r="40" fill="#FF8800" opacity="0.7"/>
        <text x="400" y="205" text-anchor="middle" fill="white">
          High
        </text>

        <!-- Mid -->
        <circle cx="400" cy="300" r="30" fill="#FFFF00" opacity="0.7"/>
        <text x="400" y="305" text-anchor="middle" fill="black">
          Mid
        </text>

        <!-- Low -->
        <circle cx="400" cy="400" r="20" fill="#88FF88" opacity="0.7"/>
        <text x="400" y="405" text-anchor="middle" fill="black">
          Low
        </text>

        <!-- ì—°ê²°ì„  -->
        <line x1="400" y1="150" x2="400" y2="160" stroke="black" stroke-width="2"/>
        <line x1="400" y1="240" x2="400" y2="270" stroke="black" stroke-width="2"/>
        <line x1="400" y1="330" x2="400" y2="380" stroke="black" stroke-width="2"/>
      </svg>
    `;
  }
}
```

---

## ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤

### ì‹œë‚˜ë¦¬ì˜¤ 1: ì •í™• ë§¤ì¹­ ì„±ê³µ

**ì…ë ¥**:
```
OCR Blocks:
1. { text: "ë‚´ì›ì¼: 2023-01-15", bbox: { Left: 0.1, Top: 0.2, Width: 0.3, Height: 0.02 } }
2. { text: "í™˜ìê°€ ë‘í†µìœ¼ë¡œ ë‚´ì›í•˜ì˜€ìŒ", bbox: { Left: 0.1, Top: 0.22, Width: 0.4, Height: 0.02 } }
3. { text: "ì§„ë£Œì¼ì: 2023-01-15", bbox: { Left: 0.1, Top: 0.24, Width: 0.3, Height: 0.02 } }
```

**ì˜ˆìƒ ê²°ê³¼**:
```javascript
{
  category: "ë‚´ì›ì¼",
  value: "2023-01-15",
  confidence: 0.95,
  contours: {
    peak: [
      { block: OCRBlock1, weight: 1.0, level: "peak" }
    ],
    high: [
      { block: OCRBlock3, weight: 0.8, level: "high" }
    ],
    mid: [
      { block: OCRBlock2, weight: 0.6, level: "mid" }
    ]
  }
}
```

---

### ì‹œë‚˜ë¦¬ì˜¤ 2: í‚¤ì›Œë“œ ìœ ì‚¬ ë§¤ì¹­

**ì…ë ¥**:
```
OCR Blocks:
1. { text: "ë°©ë¬¸ì¼: 2023-02-20", bbox: { Left: 0.1, Top: 0.3, Width: 0.3, Height: 0.02 } }
2. { text: "í™˜ì ë‚´ì›", bbox: { Left: 0.1, Top: 0.32, Width: 0.2, Height: 0.02 } }
```

**ì˜ˆìƒ ê²°ê³¼**:
```javascript
{
  category: "ë‚´ì›ì¼",
  value: "2023-02-20",
  confidence: 0.82,  // ìœ ì‚¬ í‚¤ì›Œë“œë¼ ì•½ê°„ ë‚®ìŒ
  contours: {
    peak: [],  // ì •í™• ë§¤ì¹­ ì—†ìŒ
    high: [
      { block: OCRBlock1, weight: 0.8, level: "high" }
    ],
    mid: [
      { block: OCRBlock2, weight: 0.6, level: "mid" }
    ]
  }
}
```

---

## ğŸ“ˆ ì„±ëŠ¥ ìµœì í™”

### 1. ìºì‹± ì „ëµ

```javascript
class CachedContourClassifier extends ContourWeightClassifier {
  constructor(config) {
    super(config);
    this.cache = new Map();
  }

  findPeaks(ocrBlocks, category) {
    const cacheKey = this.generateCacheKey(ocrBlocks, category);

    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }

    const result = super.findPeaks(ocrBlocks, category);
    this.cache.set(cacheKey, result);

    return result;
  }

  generateCacheKey(blocks, category) {
    const blockIds = blocks.map(b => b.id || b.text).join('|');
    return `${category}:${blockIds}`;
  }
}
```

### 2. ë³‘ë ¬ ì²˜ë¦¬

```javascript
async function processMultipleCategories(ocrBlocks, categories) {
  const classifier = new ContourWeightClassifier();
  const analyzer = new ContextFlowAnalyzer(classifier);

  // ë³‘ë ¬ë¡œ ê° ì¹´í…Œê³ ë¦¬ ì²˜ë¦¬
  const promises = categories.map(category =>
    processCategory(ocrBlocks, category, classifier, analyzer)
  );

  const results = await Promise.all(promises);

  return results.reduce((acc, result) => {
    acc[result.category] = result;
    return acc;
  }, {});
}

async function processCategory(blocks, category, classifier, analyzer) {
  const peaks = classifier.findPeaks(blocks, category);

  if (peaks.length === 0) {
    return { category, value: null, confidence: 0 };
  }

  const contours = classifier.expandContours(
    peaks[0],
    blocks,
    classifier.keywordHierarchy[category]
  );

  const result = analyzer.analyzeFlow(contours, category);

  return result;
}
```

---

## ğŸ¯ ê²°ë¡ 

ë“±ê³ ì„  ê°€ì¤‘ì¹˜ ì‹œìŠ¤í…œì€ ë‹¤ìŒê³¼ ê°™ì€ ì¥ì ì„ ì œê³µí•©ë‹ˆë‹¤:

1. **ìœ ì—°ì„±**: í‚¤ì›Œë“œ ì •í™• ë§¤ì¹­ ì‹¤íŒ¨ ì‹œì—ë„ ì£¼ë³€ ì»¨í…ìŠ¤íŠ¸ë¡œ ì •ë³´ ì¶”ì¶œ
2. **ì •ëŸ‰í™”**: ê°€ì¤‘ì¹˜ë¡œ ì‹ ë¢°ë„ë¥¼ ëª…í™•íˆ í‘œí˜„
3. **í™•ì¥ì„±**: ìƒˆë¡œìš´ ì¹´í…Œê³ ë¦¬/í‚¤ì›Œë“œ ì¶”ê°€ ìš©ì´
4. **í•´ì„ ê°€ëŠ¥ì„±**: ë“±ê³ ì„  ì‹œê°í™”ë¡œ ì¶”ì¶œ ê³¼ì • ì´í•´

ì´ ì‹œìŠ¤í…œì€ OCR ê¸°ë°˜ ì˜ë£Œ ë¬¸ì„œ ì²˜ë¦¬ì—ì„œ **99.9% ë‚ ì§œ ì •í™•ë„** ë‹¬ì„±ì„ ìœ„í•œ í•µì‹¬ ê¸°ìˆ ì…ë‹ˆë‹¤.

---

*ì‘ì„±: 2026-01-31*
*ë²„ì „: 1.0*
*ìƒíƒœ: ì„¤ê³„ ì™„ë£Œ*
