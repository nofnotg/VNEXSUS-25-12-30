단계별 실행 방안
A. 문서 템플릿 마이닝(페이지 보일러플레이트 추출)

목표: 페이지별 상단/하단/고정 문구(병원 로고, 양식표 제목, 고정 레이블) 자동 식별 → 이후 단계에서 자동 제거·마스킹.

핵심 아이디어

각 페이지를 행(라인) 배열로 보고, 같은 위치(bin: 상/중/하)에서 빈도 상위 N개 문장을 템플릿 후보로 채집.

라인 정규화(공백·특수문자·번호 토큰화) 후 TF-IDF+Jaccard로 유사 라인 군집.

template.header[] / footer[] / boilerplate[]로 저장 → 전처리 단계에서 먼저 걷어냄.

// src/template/layoutMiner.ts
export type Boilerplate = { header:string[]; footer:string[]; fixed:string[] };
export function mineBoilerplate(pages: string[][], opts={topK:5}) : Boilerplate {
  // pages[i] = lines of page i (normalized)
  const top = new Map<string, number>();
  const bot = new Map<string, number>();
  const fixed = new Map<string, number>();
  pages.forEach(lines=>{
    const bins = { top: lines.slice(0,5), bot: lines.slice(-5), mid: lines.slice(5, Math.max(5, lines.length-5)) };
    bins.top.forEach(l=> top.set(l,(top.get(l)||0)+1));
    bins.bot.forEach(l=> bot.set(l,(bot.get(l)||0)+1));
    bins.mid.forEach(l=> fixed.set(l,(fixed.get(l)||0)+1));
  });
  const pick = (m:Map<string,number>) => [...m.entries()].sort((a,b)=>b[1]-a[1]).slice(0,opts.topK).map(x=>x[0]);
  return { header: pick(top), footer: pick(bot), fixed: pick(fixed) };
}

// src/template/pageBoilerplate.ts
export function stripBoilerplate(pages: string[][], bp:Boilerplate){
  const isBoiler = (s:string)=> [...bp.header, ...bp.footer, ...bp.fixed].some(x=>similar(x,s)>=0.9);
  return pages.map(lines => lines.filter(l=>!isBoiler(l)));
}
function similar(a:string,b:string){ // 간단 유사도
  const A=new Set(a.split(/\s+/)), B=new Set(b.split(/\s+/));
  const I=[...A].filter(x=>B.has(x)).length;
  return I/Math.max(1, A.size+B.size-I);
}


효과: 페이지 상·하단/고정 라벨 제거만으로 노이즈 20~40% 감소. 헤더/푸터에 있는 병원명·로고도 자동 처리.

B. 세그먼트 & 앵커(날짜·기관·행위) + 선행/후행 귀속 규칙

목표: “문서→페이지→세그먼트(단락)→날짜블록→이벤트” 계층을 확립. 날짜 앞뒤의 문장 둘 다 다루는 귀속 규칙.

// src/segment/anchors.ts
export const DATE = /\b(19|20)\d{2}[./-](0?[1-9]|1[0-2])[./-](0?[1-9]|[12]\d|3[01])\b|(\d{4})년\s?(1?\d)월\s?(3?\d)일/;
export const HOSP = /(병원|의료원|센터|의원|대학교병원|보건소)/;
export const ACT  = /(입원|퇴원|수술|시술|처치|검사|초음파|MRI|CT|내시경|처방|투약|재진|초진)/;

export function lineScore(s:string){
  return (DATE.test(s)?3:0) + (HOSP.test(s)?1:0) + (ACT.test(s)?2:0);
}
export function splitSegments(lines:string[]){
  const cuts:number[]=[]; let rolling=0;
  for (let i=0;i<lines.length;i++){
    const sc=lineScore(lines[i]); const up= sc - rolling;
    if (DATE.test(lines[i]) || up>=3) cuts.push(i); // 앵커
    rolling = (rolling*0.7)+sc*0.3;
  }
  return cuts.map((st,idx)=> lines.slice(st, cuts[idx+1] ?? lines.length));
}


선행/후행 귀속 규칙(룰엔진에서 적용)

후행 기본: 날짜라인 이후 k줄(기본 8줄)까지 해당 날짜 블록

선행 예외: 날짜라인 직전 1–2줄에 행위/기관/진단 신호가 강하면(스코어≥τ) 해당 날짜로 선행 귀속

단락 경계 보호: 두 날짜 사이 기관·과·차트번호 등 컨텍스트가 유지되면 동일 블록

// src/segment/dateBlocker.ts
export function toDateBlocks(segment:string[]){
  const idxs = segment.map((l,i)=> DATE.test(l)?i:-1).filter(i=>i>=0);
  const blocks: string[][] = [];
  for (let x=0; x<idxs.length; x++){
    const start = Math.max(0, idxs[x]-2); // 선행 2줄 포함 후보
    const end = idxs[x+1] ? idxs[x+1] : segment.length;
    const slice = segment.slice(start, end);
    blocks.push(adjustLeading(slice)); // 선행 귀속 보정
  }
  return blocks;
}
function adjustLeading(lines:string[]){
  // 맨 앞 1~2줄에 ACT/HOSP 신호가 강하면 유지, 약하면 버리고 뒤로 귀속
  const lead = lines.slice(0,2), rest = lines.slice(2);
  const strong = lead.some(l=> lineScore(l)>=3 && !DATE.test(l));
  return strong ? lines : rest;
}

C. PII/고정 레이블·활력징후 등 최소 삭제, 정보 보존형 태깅

피보험자 외 개인식별(의료진/서명/전화/주소)·활력징후·접수·청구 등은 [ADMIN] 태그로 이동(삭제 X).

‘기타’는 [LOW-LINK] 또는 [CONTEXT] 태그로 보존.

근거 span/page:line를 evidence에 남겨 감사추적.

// src/clean/piiScrubber.ts
const PII = [/전화[:\s]\d{2,3}-\d{3,4}-\d{4}/, /(의사|간호사|담당의)[:\s]?[가-힣]{2,}/, /(주소|Fax)[:\s]/];
const VITAL = /(BT|BP|HR|RR|SpO2)\s*[:=]/i;
export function scrubMinimal(lines:string[]){
  return lines.map(l=>{
    if (PII.some(re=>re.test(l)) || VITAL.test(l)) return `[ADMIN] ${l}`;
    return l;
  });
}

D. “굵은 줄기(Trunk)” 분류기(룰엔진) + 전처리AI의 보조 힌트

Trunk 카테고리: DEATH | CANCER | NEURO | CARDIO | HEPATIC | SURGERY | ADMISSION | EXAM

룰엔진은 코드/키워드/서술 패턴으로 1차 결정, 전처리AI는 raw→canonical 후보 + 근거스팬만 제공.

이 카테고리를 episode/link 스코어의 가중치로 사용(예: CANCER는 test→treat 윈도우 확대).

// src/rules/trunkClassifier.ts
export function trunkOf(ev:{dx?:string; text?:string}){
  const t = (ev.dx||"")+" "+(ev.text||"");
  if (/\b사망\b/.test(t)) return "DEATH";
  if (/\b(C\d{2}|암|항암)\b/.test(t)) return "CANCER";
  if (/\b(I6\d|뇌졸중|중풍|경색)\b/.test(t)) return "NEURO";
  if (/\b(I2\d|협심증|심근경색|스텐트)\b/.test(t)) return "CARDIO";
  if (/\b(B1\d|간경화|간암|간부전)\b/.test(t)) return "HEPATIC";
  if (/(수술|절제|봉합|관삽입)/.test(t)) return "SURGERY";
  if (/(입원|퇴원)/.test(t)) return "ADMISSION";
  if (/(검사|CT|MRI|내시경|초음파)/.test(t)) return "EXAM";
  return "OTHER";
}

E. 전처리AI 프롬프트(룰엔진 주도형) — “세그먼트·태깅·근거·후보”

금지: 삭제/정렬/병합/요약/판단.

요구: 각 항목 raw를 유지하고, canonical?, candidates[], spans[]를 함께.

세그먼트 기준: 날짜·기관·행위 앵커, 보일러플레이트 제거 이후 라인.

[SYSTEM]
역할: 의료 OCR 텍스트를 룰엔진 친화적 JSON으로 '세그먼트·태깅·근거·후보'를 제공한다.
금지: 삭제/정렬/병합/요약/판단.
요구: raw 유지 + canonical 후보(0~3개) + spans(page:line 또는 char-index).
notes는 [LOW-LINK]/[ADMIN]/[CONTEXT] 태그만 부여(내용 삭제 금지).

[USER]
입력(보일러플레이트 제거/PII 마스킹 후 라인):
<<<
{{lines_joined}}
>>>
사전 힌트(선택): 병원·검사·시술·약물 동의어 사전 요약

출력 스키마(Data Contract v1):
- events[].date{raw, iso?, candidates[], confidence}
- hospital{raw, canonical?, candidates[]}
- visitType{raw, canonical?}
- dx{raw[], code3?, candidates[]}
- tests[]/procedures[]/meds[]{raw, canonical?, attrs?, confidence, spans[]}
- notes{raw, tags[], spans[]}
- evidence{spans[]}
- flags[]

주의: 동일 문서 내 이벤트 순서는 입력 순서 유지. 판단/병합/정렬 금지.

F. 링크·에피소드(룰엔진 선도) + “선행/후행” 귀속 반영

linker.ts에서 의심→검사(≤14d), 검사→치료(≤30d), 치료→추적(≤180d) 등 시퀀스 룰 + dxCode3/유사도 적용.

episode.ts에서 병원Std+과+dxCode3 단위로 방문 간격 윈도우(기본 28d, 질환별 상향)로 그룹화.

전처리AI가 준 spans를 evidence로 유지 → 보고서/리뷰 시 하이라이트 가능.

G. 보고서AI(9항목) — 트렁크/링크 가시화

상단에 Episode Index(통원 회수/핵심행위)

각 행 기타 끝에 (links: test#3, treat#5)

동일일자 다건 병합 표기: 검사(3건: CT, CBC, LFT)

고려사항 맵

균형: 전처리AI는 “풍성한 후보·근거 제공”까지, 결정은 룰엔진. AI가 과도하게 정규화/삭제하지 않도록 가드레일.

성능: 템플릿 마이닝은 문서 묶음(batch)에서 1회 캐시. 런타임에는 캐시된 보일러플레이트로 빠르게 제거.

안전성: 플래그로 점진 적용(featureFlags.yml): template_mining, leading_attach, trunk_class.

검증: 30문서 파일럿 → 노이즈 비율(삭제가 아닌 태깅 전환)·블록정합률·링크 precision/recall 보고.

확장 시야 (20%)

기관별 템플릿 캐시: 병원명 canonical이 확정되면 해당 병원의 보일러플레이트 패턴을 캐시(자동 업데이트).

약물 파라메트릭 링크: 용량/주기 변화 탐지 → episode 내 약물조정 이벤트로 태깅.

간단 임베딩 룰 보조: 검사·시술 동의어 매칭을 사전+임베딩 하이브리드로 향상.

실행 리소스 (붙여 쓰는 핵심 코드)
1) 파이프라인 진입점(기존 흐름 유지)
// src/index.ts (개념)
import { mineBoilerplate, stripBoilerplate } from "~/template/layoutMiner";
import { splitSegments, toDateBlocks } from "~/segment/dateBlocker";
import { scrubMinimal } from "~/clean/piiScrubber";
// 1) OCR → pages(lines) 로딩
// 2) bp = mineBoilerplate(pagesCacheByHospital) 또는 캐시 사용
// 3) pages2 = stripBoilerplate(pages, bp)
// 4) lines = pages2.flat()
// 5) segs = splitSegments(lines) → segs.flatMap(toDateBlocks)
// 6) (선택) 전처리AI 호출 → Data Contract v1 (raw+canonical 후보+spans)
// 7) 룰엔진 canonicalize/link/episode → 보고서AI

2) 전처리AI 호출(삭제/정렬/병합 금지)
// src/preprocess/callPreAI.ts (개념)
const system = fs.readFileSync("prompts/PRE_AI_SYSTEM@v1.txt","utf8");
const user   = render("prompts/PRE_AI_USER@v1.hbs",{ lines_joined, lex });
const res = await openai.chat.completions.create({ model:"gpt-4o-mini", temperature:0.1, messages:[{role:"system",content:system},{role:"user",content:user}] });
// -> Data Contract v1 JSON

3) 선행/후행 귀속 파라미터
# config/linking.yml
leading_attach_lines: 2
following_attach_lines: 8
